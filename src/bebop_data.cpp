#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>
#include "std_msgs/String.h"
#include "std_msgs/Empty.h"
#include "std_msgs/Bool.h"
#include "std_srvs/Empty.h"
#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/time.h>

#include <stdlib.h>
#include <opencv2/opencv.hpp>

#include <image_transport/image_transport.h>
#include <image_transport/subscriber_filter.h>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/exact_time.h>
#include <message_filters/sync_policies/approximate_time.h>

#include <opencv2/opencv.hpp>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/exact_time.h>
#include <sensor_msgs/Image.h>
#include <opencv2/calib3d/calib3d.hpp>
#include <opencv2/opencv.hpp>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/calib3d/calib3d.hpp>
#include <sensor_msgs/image_encodings.h>
#include <nodelet/nodelet.h>

#include <opencv2/calib3d/calib3d.hpp>
#include <cv_bridge/cv_bridge.h>

#include <sensor_msgs/image_encodings.h>

#include <sensor_msgs/NavSatFix.h>
#include <fstream>
#include <iomanip>
#include <cmath>
#include <limits>

#include <ctime>
#include <ratio>
#include <chrono>
#include <utility>
#include <thread>
#include <chrono>
#include <functional>
#include <atomic>

#include <std_msgs/Header.h>

#include <tf/transform_listener.h>

#include <tf2_ros/transform_listener.h>

#include <std_msgs/Header.h>

#include <bebop_data/tf_stamped.h>

#include <nav_msgs/Odometry.h>

// #include <bebop_msgs/Ardrone3PilotingStateAltitudeChanged.h>
// #include <bebop_driver/BebopArdrone3Config.h>
// #include <bebop_driver/autogenerated/ardrone3_state_callbacks.h>

using namespace sensor_msgs;
using namespace message_filters;
using namespace cv;
using namespace ros;
using namespace std;
using namespace std::chrono;
using namespace std_msgs;
// using namespace bebop_data;
  
int base_number = 0;

ros::Publisher tf_pub_;
ros::Subscriber tf_sub_;

ros::Publisher vel_pub_;

void dataCallback(const ImageConstPtr& img, const NavSatFixConstPtr& the_fix, const bebop_data::tf_stampedConstPtr& orb, const nav_msgs::OdometryConstPtr& odom) {

  char filename[128];

  long double lat, lon;

  lat = the_fix->latitude;
  lon = the_fix->longitude;

  sprintf(filename, "/path/to/folder/frame%06d.png", base_number);       // Set the path

  std::ofstream outfile_text, outfile_gps, outfile_orb, outfile_odom;
  outfile_text.open("image_file.txt", std::ios_base::app);
  outfile_gps.open("gps_file.txt", std::ios_base::app);
  outfile_orb.open("orb_file.txt", std::ios_base::app);
  outfile_odom.open("odom_file.txt", std::ios_base::app);
  outfile_text << filename << "\n";
  outfile_gps << std::setprecision(10) << lat << "," << std::setprecision(10) << lon << "\n";
  outfile_orb <<  orb->trans.translation.x << "," << orb->trans.translation.y << "," << orb->trans.translation.z << "," << orb->trans.rotation.x << "," << orb->trans.rotation.y << "," << orb->trans.rotation.z << "," << orb->trans.rotation.w << "\n"; 
  outfile_odom <<  odom->pose.pose.position.x << "," << odom->pose.pose.position.y << "," << odom->pose.pose.position.z << "," << odom->pose.pose.orientation.x << "," << odom->pose.pose.orientation.y << "," << odom->pose.pose.orientation.z << "," << odom->pose.pose.orientation.w << "\n";

  cv::imwrite(filename, cv_bridge::toCvShare(img, sensor_msgs::image_encodings::BGR8)->image);

  base_number++;

}


void tfCallback( const tf2_msgs::TFMessageConstPtr& tf_msg ) {

  bebop_data::tf_stamped tf_msg_stamped;

  tf_msg_stamped.header.stamp = tf_msg->transforms[0].header.stamp; // ros::Time::now();

  if(tf_msg->transforms[0].child_frame_id.compare("ORB_SLAM/Camera") == 0) {
    tf_msg_stamped.header.frame_id = "camera_frame";

    tf_msg_stamped.trans = tf_msg->transforms[0].transform;

    tf_pub_.publish(tf_msg_stamped);
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "image_gps_slam");

  cout << "Enter base number -- ";

  cin >> base_number;

  ros::NodeHandle nh_;

  tf_pub_ = nh_.advertise<bebop_data::tf_stamped>("/tf_stamped", 1);
  tf_sub_ = nh_.subscribe<tf2_msgs::TFMessage>("/tf", 10, tfCallback);

  vel_pub_ = nh_.advertise<geometry_msgs::Twist>("/bebop/cmd_vel", 1);

  message_filters::Subscriber<Image> img_sub(nh_, "/bebop/image_raw", 1);
  message_filters::Subscriber<sensor_msgs::NavSatFix> gps_sub(nh_, "/bebop/fix", 1);
  message_filters::Subscriber<bebop_data::tf_stamped> tf_sub(nh_, "/tf_stamped", 1);

  // message_filters::Subscriber<bebop_msgs::Ardrone3PilotingStateAltitudeChanged> alt_sub(nh_, "/bebop/states/ARDrone3/PilotingState/AltitudeChanged", 1);

  message_filters::Subscriber<nav_msgs::Odometry> odom_sub(nh_, "/bebop/odom", 1);

  typedef sync_policies::ApproximateTime<Image, sensor_msgs::NavSatFix, bebop_data::tf_stamped, nav_msgs::Odometry> MySyncPolicy;

  Synchronizer<MySyncPolicy> sync_1(MySyncPolicy(10), img_sub, gps_sub, tf_sub, odom_sub);

  sync_1.registerCallback(boost::bind(&dataCallback, _1, _2, _3, _4));
  
  ros::spin();
}